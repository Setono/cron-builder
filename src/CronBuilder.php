<?php

declare(strict_types=1);

namespace Setono\CronBuilder;

use Setono\CronBuilder\VariableResolver\PhpBinaryVariableResolver;
use function Safe\sprintf;
use Setono\CronBuilder\Config\Processor;
use Setono\CronBuilder\ExpressionLanguage\Context;
use Setono\CronBuilder\VariableResolver\ExpressionLanguageAwareInterface;
use Setono\CronBuilder\VariableResolver\ExprVariableResolver;
use Setono\CronBuilder\VariableResolver\VariableResolverInterface;
use Symfony\Component\ExpressionLanguage\ExpressionLanguage;
use Symfony\Component\Finder\Finder;
use Symfony\Component\OptionsResolver\OptionsResolver;
use Symfony\Component\Yaml\Yaml;
use Webmozart\Assert\Assert;

final class CronBuilder
{
    private ExpressionLanguage $expressionLanguage;

    private array $options;

    /** @var VariableResolverInterface[] */
    private array $variableResolvers = [];

    public function __construct(array $options = [], ExpressionLanguage $expressionLanguage = null)
    {
        $this->expressionLanguage = $expressionLanguage ?? new ExpressionLanguage();

        $resolver = new OptionsResolver();
        $this->configureOptions($resolver);
        $this->options = $resolver->resolve($options);
    }

    public function build(array $context = []): string
    {
        $finder = new Finder();
        $finder->files()->in($this->options['source']);

        $configs = [];
        foreach ($finder as $file) {
            $configs[] = Yaml::parseFile($file->getRealPath());
        }

        $processor = new Processor();
        $configs = $processor->process($configs);
        $expressionLanguageValues = [
            'context' => new Context($context),
        ];

        $newCron = '';
        foreach ($configs as $config) {
            if (null !== $config->getCondition()) {
                $res = $this->expressionLanguage->evaluate($config->getCondition(), $expressionLanguageValues);

                Assert::boolean($res, 'The condition must evaluate to a boolean');

                if (false === $res) {
                    continue;
                }
            }

            $configStr = (string) $config;
            foreach ($this->variableResolvers as $variableResolver) {
                if ($variableResolver instanceof ExpressionLanguageAwareInterface) {
                    $variableResolver->setExpressionLanguage($this->expressionLanguage, $expressionLanguageValues);
                }
                $configStr = $variableResolver->resolve($configStr, $this->options);
            }

            $newCron .= $configStr . "\n";
        }

        if ('' === $newCron) {
            return '';
        }

        return $this->getDelimiter('begin') . "\n" . $newCron . $this->getDelimiter('end') . "\n";
    }

    public function merge(string $oldCron, string $newCron): string
    {
        if ('' === $oldCron) {
            return $newCron;
        }

        return preg_replace(
            sprintf('/%s.*%s\n/m', $this->getDelimiter('begin'), $this->getDelimiter('end')),
            '',
            $oldCron
        );
    }

    public function addVariableResolver(VariableResolverInterface $variableResolver): void
    {
        $this->variableResolvers[] = $variableResolver;
    }

    public function configureOptions(OptionsResolver $resolver): void
    {
        $resolver->setDefaults([
            'source' => 'etc/cronjobs',
            'delimiter' => 'Automatically generated by Setono Cron Builder - Do not edit',
        ]);
    }

    private function getDelimiter(string $type): string
    {
        Assert::oneOf($type, ['begin', 'end']);

        if ($type === 'begin') {
            return '###> ' . $this->options['delimiter'] . ' ###';
        }

        return '###< ' . $this->options['delimiter'] . ' ###';
    }
}
