<?php

declare(strict_types=1);

namespace Setono\CronBuilder;

use function Safe\preg_replace;
use function Safe\sprintf;
use Setono\CronBuilder\Config\Processor;
use Setono\CronBuilder\ExpressionLanguage\Context;
use Setono\CronBuilder\VariableResolver\ExpressionLanguageAwareInterface;
use Setono\CronBuilder\VariableResolver\VariableResolverInterface;
use Symfony\Component\ExpressionLanguage\ExpressionLanguage;
use Symfony\Component\Finder\Finder;
use Symfony\Component\OptionsResolver\OptionsResolver;
use Symfony\Component\Yaml\Yaml;
use Webmozart\Assert\Assert;

final class CronBuilder
{
    private ExpressionLanguage $expressionLanguage;

    /**
     * This will hold the last expression language values
     */
    private array $expressionLanguageValues = [];

    private array $options;

    /** @var VariableResolverInterface[] */
    private array $variableResolvers = [];

    public function __construct(array $options = [], ExpressionLanguage $expressionLanguage = null)
    {
        $this->expressionLanguage = $expressionLanguage ?? new ExpressionLanguage();

        $resolver = new OptionsResolver();
        $this->configureOptions($resolver);
        $this->options = $resolver->resolve($options);
    }

    public function build(array $context = []): string
    {
        $this->expressionLanguageValues = [
            'context' => new Context($context),
        ];

        $finder = new Finder();
        $finder->files()->in($this->options['source']);

        $configs = [];
        foreach ($finder as $file) {
            $configs[] = Yaml::parseFile((string) $file->getRealPath());
        }

        $processor = new Processor();
        $configs = $processor->process($configs);

        $newCron = '';
        foreach ($configs as $config) {
            if (null !== $config->getCondition()) {
                $res = $this->expressionLanguage->evaluate($config->getCondition(), $this->expressionLanguageValues);

                Assert::boolean($res, 'The condition must evaluate to a boolean');

                if (false === $res) {
                    continue;
                }
            }

            $crontabLine = $this->resolveVariables($config->getCrontabLine());

            $newCron .= $crontabLine . "\n";
        }

        if ('' === $newCron) {
            return '';
        }

        return $this->getDelimiter('begin') . "\n" . $newCron . $this->getDelimiter('end') . "\n";
    }

    public function merge(string $oldCron, string $newCron): string
    {
        if ('' === $oldCron) {
            return $newCron;
        }

        return preg_replace(
            sprintf('/%s.*%s\n/ms', $this->getDelimiter('begin'), $this->getDelimiter('end')),
            $newCron,
            $oldCron
        );
    }

    public function addVariableResolver(VariableResolverInterface $variableResolver): void
    {
        $this->variableResolvers[] = $variableResolver;
    }

    public function configureOptions(OptionsResolver $resolver): void
    {
        $resolver->setDefaults([
            'source' => 'etc/cronjobs',
            'delimiter' => 'Automatically generated by Setono Cron Builder - Do not edit',
        ]);
    }

    private function resolveVariables(string $str): string
    {
        foreach ($this->variableResolvers as $variableResolver) {
            if ($variableResolver instanceof ExpressionLanguageAwareInterface) {
                $variableResolver->setExpressionLanguage($this->expressionLanguage, $this->expressionLanguageValues);
            }
            $str = $variableResolver->resolve($str, $this->options);
        }

        return $str;
    }

    private function getDelimiter(string $type): string
    {
        Assert::oneOf($type, ['begin', 'end']);

        if ($type === 'begin') {
            return $this->resolveVariables('###> ' . $this->options['delimiter'] . ' ###');
        }

        return $this->resolveVariables('###< ' . $this->options['delimiter'] . ' ###');
    }
}
