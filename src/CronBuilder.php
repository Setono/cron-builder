<?php

declare(strict_types=1);

namespace Setono\CronBuilder;

use function Safe\preg_replace;
use function Safe\sprintf;
use Setono\CronBuilder\Config\Config;
use Setono\CronBuilder\Config\Processor;
use Setono\CronBuilder\ExpressionLanguage\Context;
use Setono\CronBuilder\VariableResolver\ExpressionLanguageAwareInterface;
use Setono\CronBuilder\VariableResolver\VariableResolverInterface;
use Symfony\Component\ExpressionLanguage\ExpressionLanguage;
use Symfony\Component\Finder\Finder;
use Symfony\Component\OptionsResolver\OptionsResolver;
use Symfony\Component\Yaml\Yaml;
use Traversable;
use Webmozart\Assert\Assert;

final class CronBuilder
{
    private ExpressionLanguage $expressionLanguage;

    /**
     * This will hold the last expression language values
     */
    private array $expressionLanguageValues = [];

    private array $options;

    /** @var VariableResolverInterface[] */
    private array $variableResolvers = [];

    public function __construct(array $options = [], ExpressionLanguage $expressionLanguage = null)
    {
        $this->expressionLanguage = $expressionLanguage ?? new ExpressionLanguage();

        $resolver = new OptionsResolver();
        $this->configureOptions($resolver);
        $this->options = $resolver->resolve($options);
    }

    /**
     * This method only validates the config files' structure. It doesn't validate whether a config file actually
     * resolves to a valid cron line in the end since this depends on your used variables, context, variable resolvers etc.
     */
    public function validate(): void
    {
        $iterator = $this->processConfigFiles();
        if ($iterator instanceof Traversable) {
            iterator_to_array($iterator);
        }
    }

    public function build(array $context = []): string
    {
        $this->expressionLanguageValues = [
            'context' => new Context($context),
        ];

        $configs = $this->processConfigFiles();

        $newCron = '';
        foreach ($configs as $config) {
            if (null !== $config->condition) {
                $res = $this->expressionLanguage->evaluate($config->condition, $this->expressionLanguageValues);

                Assert::boolean($res, 'The condition must evaluate to a boolean');

                if (false === $res) {
                    continue;
                }
            }

            $crontabLine = $this->resolveVariables($config->getCrontabLine());

            $newCron .= $crontabLine . "\n";
        }

        if ('' === $newCron) {
            return '';
        }

        $newCron = rtrim($newCron, "\n");

        return $this->getDelimiter('begin') . "\n" . $newCron . "\n" . $this->getDelimiter('end');
    }

    public function merge(string $oldCron, string $newCron): string
    {
        if ('' === $oldCron) {
            return $newCron;
        }

        $replacedCron = preg_replace(
            sprintf('/%s.*%s/ms',
                preg_quote($this->getDelimiter('begin'), '/'),
                preg_quote($this->getDelimiter('end'), '/')
            ),
            $newCron,
            $oldCron,
            -1,
            $replacements
        );

        Assert::lessThanEq($replacements, 1, 'The number of replacements should be 1 or 0');

        if ($replacements > 0) {
            return $replacedCron;
        }

        return $oldCron . "\n" . $newCron;
    }

    public function addVariableResolver(VariableResolverInterface $variableResolver): void
    {
        $this->variableResolvers[] = $variableResolver;
    }

    public function configureOptions(OptionsResolver $resolver): void
    {
        $resolver->setDefaults([
            'source' => 'etc/cronjobs',
            'delimiter' => 'Automatically generated by Setono Cron Builder - Do not edit',
        ]);
    }

    /**
     * @return Config[]
     */
    private function processConfigFiles(): iterable
    {
        $finder = new Finder();
        $finder->files()->in($this->options['source']);

        $configs = [];
        foreach ($finder as $file) {
            $configs[] = Yaml::parseFile((string) $file->getRealPath());
        }

        $processor = new Processor();
        yield from $processor->process($configs);
    }

    private function resolveVariables(string $str): string
    {
        foreach ($this->variableResolvers as $variableResolver) {
            if ($variableResolver instanceof ExpressionLanguageAwareInterface) {
                $variableResolver->setExpressionLanguage($this->expressionLanguage, $this->expressionLanguageValues);
            }
            $str = $variableResolver->resolve($str);
        }

        return $str;
    }

    private function getDelimiter(string $type): string
    {
        Assert::oneOf($type, ['begin', 'end']);

        if ($type === 'begin') {
            return $this->resolveVariables('###> ' . $this->options['delimiter'] . ' ###');
        }

        return $this->resolveVariables('###< ' . $this->options['delimiter'] . ' ###');
    }
}
